#!/bin/bash

# AWS EC2 Instance Connection Script
# This script connects to EC2 instances via AWS Systems Manager (SSM)
# Supports direct connection or port forwarding tunnel with background mode

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Script configuration
readonly SCRIPT_NAME=$(basename "$0")
readonly REQUIRED_COMMANDS=("aws" "awk" "pgrep" "pkill" "jq")

# Default values
readonly DEFAULT_CONNECTION_METHOD="connect"

# Valid environments and their AWS account mappings
readonly VALID_ENVIRONMENTS=("staging" "production" "management")

# Helper functions to get account info (compatible with older bash)
get_environment_account() {
    case "$1" in
        "staging") echo "086920961728" ;;
        "production") echo "086962800241" ;;
        "management") echo "073638633986" ;;
        *) return 1 ;;
    esac
}

# Tunnel management - use user-specific directory for security
readonly TUNNEL_PIDFILE_DIR="${HOME}/.cache/ssm-connect"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Global variables for signal handling
BACKGROUND_TUNNEL_PID=""
CURRENT_PIDFILE=""

# Logging functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Signal handler for cleanup on interruption
cleanup_on_signal() {
    local signal="$1"
    log_warn "Received signal $signal, cleaning up..."

    # Clean up background tunnel if running
    if [[ -n "$BACKGROUND_TUNNEL_PID" ]] && kill -0 "$BACKGROUND_TUNNEL_PID" 2>/dev/null; then
        log_info "Stopping background tunnel (PID: $BACKGROUND_TUNNEL_PID)"
        kill "$BACKGROUND_TUNNEL_PID" 2>/dev/null || true
    fi

    # Clean up PID file
    if [[ -n "$CURRENT_PIDFILE" && -f "$CURRENT_PIDFILE" ]]; then
        rm -f "$CURRENT_PIDFILE"
    fi

    exit 130  # Standard exit code for SIGINT
}

# Set up signal handlers
setup_signal_handlers() {
    trap 'cleanup_on_signal INT' INT
    trap 'cleanup_on_signal TERM' TERM
    trap 'cleanup_on_signal HUP' HUP
}

# Show usage information
show_usage() {
    cat << EOF
Usage: $SCRIPT_NAME <instance-name> <environment> [connect|tunnel|background|cleanup] <port-number> <local-port-number>

Connect to EC2 instances via AWS Systems Manager (SSM).

Arguments:
    instance-name       Name of the EC2 instance (from Name tag)
    environment        Environment tag value (staging, production, management, uat)
    connection-method  Connection mode:
                        - 'connect': Direct interactive connection
                        - 'tunnel': Port forwarding tunnel (foreground)
                        - 'background': Port forwarding tunnel (background)
                        - 'cleanup': Kill existing tunnels for this instance
    port-number        Remote port number for tunneling (required for tunnel/background modes)
    local-port-number  Local port number for tunneling (required for tunnel/background modes)

Examples:
    # HashiCorp services (all run in management account)
    $SCRIPT_NAME nomad-server-management management background 4646 4646
    $SCRIPT_NAME vault-server management tunnel 8200 8200
    $SCRIPT_NAME consul-server management tunnel 8500 8500

    # Cleanup
    $SCRIPT_NAME nomad-server-management management cleanup

Makefile integration examples:
    # Creates background tunnel to management account for Nomad access
    make login-staging: Uses nomad-server-management in management account

    # All HashiCorp services are accessed via management account:
    ./ssm-connect nomad-server-management management background 4646 4646
    ./ssm-connect vault-server management background 8200 8200
    ./ssm-connect consul-server management background 8500 8500

Common service ports:
    - Consul: 8500
    - Vault: 8200
    - Nomad: 4646

Account Requirements:
    - staging: Must be in AWS account 086920961728 (ke-staging)
    - production: Must be in AWS account 086962800241 (ke-production)
    - management: Must be in AWS account 073638633986 (ke-management)

Requirements:
    - AWS CLI configured with appropriate credentials
    - SSM permissions for target instances
    - Instances must have SSM agent installed and running

EOF
}

# Check if required commands are available
check_dependencies() {
    local missing_commands=()

    for cmd in "${REQUIRED_COMMANDS[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
        fi
    done

    if [ ${#missing_commands[@]} -ne 0 ]; then
        log_error "Missing required commands: ${missing_commands[*]}"
        log_error "Please install the missing commands and try again."
        exit 2
    fi
}

# Validate AWS CLI configuration
check_aws_config() {
    if ! aws sts get-caller-identity &> /dev/null; then
        log_error "AWS CLI is not properly configured or you don't have permissions."
        log_error "Please run 'aws configure' or check your credentials."
        exit 3
    fi
}

# Validate AWS account for environment (no role validation)
validate_aws_account() {
    local environment="$1"

    local expected_account

    if ! expected_account=$(get_environment_account "$environment"); then
        log_error "Unknown environment: $environment"
        return 8
    fi

    # Skip validation for uat environment (no specific account requirement)
    if [[ "$environment" == "uat" || -z "$expected_account" ]]; then
        return 0
    fi

    log_info "Validating AWS account for $environment environment..."

    # Get current caller identity
    local caller_identity
    if ! caller_identity=$(aws sts get-caller-identity 2>/dev/null); then
        log_error "Failed to get AWS caller identity"
        return 3
    fi

    # Extract account
    local current_account
    current_account=$(echo "$caller_identity" | grep -o '"Account": "[^"]*"' | cut -d'"' -f4)

    # Validate account
    if [[ "$current_account" != "$expected_account" ]]; then
        log_error "Wrong AWS account for $environment environment"
        log_error "Expected: $expected_account, Current: $current_account"
        log_error "Please switch to the correct AWS account for the $environment environment"
        return 8
    fi

    log_info "✓ AWS account validation passed for $environment"
    return 0
}

# Validate input parameters
validate_inputs() {
    local instance_name="$1"
    local environment="$2"
    local connection_method="$3"
    local port_number="$4"
    local local_port_number="$5"

    # Check for empty instance name
    if [[ -z "$instance_name" ]]; then
        log_error "Instance name cannot be empty"
        return 1
    fi

    # Check for empty environment
    if [[ -z "$environment" ]]; then
        log_error "Environment cannot be empty"
        return 1
    fi

    # Validate environment against allowed values
    local valid_env=false
    for env in "${VALID_ENVIRONMENTS[@]}"; do
        if [[ "$environment" == "$env" ]]; then
            valid_env=true
            break
        fi
    done

    if [[ "$valid_env" == false ]]; then
        log_error "Invalid environment: $environment"
        log_error "Valid environments are: ${VALID_ENVIRONMENTS[*]}"
        return 1
    fi

    # Validate connection method
    if [[ "$connection_method" != "connect" && "$connection_method" != "tunnel" && "$connection_method" != "background" && "$connection_method" != "cleanup" ]]; then
        log_error "Invalid connection method: $connection_method"
        log_error "Valid options are: 'connect', 'tunnel', 'background', or 'cleanup'"
        return 1
    fi

    # Validate port numbers (required for tunneling and background modes)
    if [[ "$connection_method" == "tunnel" || "$connection_method" == "background" ]]; then
        if [[ -z "$port_number" ]]; then
            log_error "Port number is required for tunnel mode"
            log_error "Please specify both remote and local port numbers"
            return 1
        fi

        if [[ -z "$local_port_number" ]]; then
            log_error "Local port number is required for tunnel mode"
            log_error "Please specify both remote and local port numbers"
            return 1
        fi

        if ! [[ "$port_number" =~ ^[0-9]+$ ]] || [ "$port_number" -lt 1 ] || [ "$port_number" -gt 65535 ]; then
            log_error "Invalid port number: $port_number"
            log_error "Port must be between 1 and 65535"
            return 1
        fi

        if ! [[ "$local_port_number" =~ ^[0-9]+$ ]] || [ "$local_port_number" -lt 1 ] || [ "$local_port_number" -gt 65535 ]; then
            log_error "Invalid local port number: $local_port_number"
            log_error "Port must be between 1 and 65535"
            return 1
        fi
    fi

    return 0
}

# Find the instance ID based on Name and Environment tags
get_instance_id() {
    local name="$1"
    local env="$2"

    log_info "Searching for instance: Name=$name, Environment=$env"

    local instance_id
    instance_id=$(aws ec2 describe-instances \
        --filters \
            "Name=tag:Name,Values=${name}" \
            "Name=tag:Environment,Values=${env}" \
            "Name=instance-state-name,Values=running" \
        --query "Reservations[].Instances[].InstanceId" \
        --output text 2>/dev/null) || {
        log_error "Failed to query AWS EC2 instances"
        return 4
    }

    # Check if any instances were found
    if [[ -z "$instance_id" ]]; then
        log_error "No running instances found with Name='$name' and Environment='$env'"
        log_error "Please verify the instance name and environment are correct"
        return 5
    fi

    # Check if multiple instances were found
    local instance_count
    instance_count=$(echo "$instance_id" | wc -w)
    if [ "$instance_count" -gt 1 ]; then
        log_warn "Multiple instances found ($instance_count):"
        echo "$instance_id" | tr '\t' '\n' | while read -r id; do
            log_warn "  - $id"
        done
        log_info "Using the first instance: $(echo "$instance_id" | awk '{print $1}')"
    fi

    # Return the first instance ID
    echo "$instance_id" | awk '{print $1}'
}

# Get PID file path for tunnel
get_tunnel_pidfile() {
    local instance_name="$1"
    local environment="$2"
    local local_port="$3"

    # Ensure PID directory exists
    mkdir -p "$TUNNEL_PIDFILE_DIR"

    echo "${TUNNEL_PIDFILE_DIR}/ssm-tunnel-${instance_name}-${environment}-${local_port}.pid"
}

# Check if tunnel is running
is_tunnel_running() {
    local pidfile="$1"

    if [[ ! -f "$pidfile" ]]; then
        return 1
    fi

    local pid
    pid=$(cat "$pidfile" 2>/dev/null || echo "")

    if [[ -z "$pid" ]]; then
        return 1
    fi

    if ! kill -0 "$pid" 2>/dev/null; then
        # Process doesn't exist, clean up stale pidfile
        rm -f "$pidfile"
        return 1
    fi

    return 0
}

# Kill existing tunnel processes
cleanup_tunnels() {
    local instance_name="$1"
    local environment="$2"
    local local_port="${3:-}"

    log_info "Cleaning up existing tunnels for $instance_name ($environment)..."

    # If specific port provided, clean up only that tunnel
    if [[ -n "$local_port" ]]; then
        local pidfile
        pidfile=$(get_tunnel_pidfile "$instance_name" "$environment" "$local_port")

        if is_tunnel_running "$pidfile"; then
            local pid
            pid=$(cat "$pidfile")
            log_info "Stopping tunnel process $pid (port $local_port)"
            kill "$pid" 2>/dev/null || true
            rm -f "$pidfile"
        fi
        return 0
    fi

    # Clean up all tunnels for this instance
    local pattern="${TUNNEL_PIDFILE_DIR}/ssm-tunnel-${instance_name}-${environment}-*.pid"
    local cleaned=0

    for pidfile in $pattern; do
        if [[ -f "$pidfile" ]]; then
            local port
            port=$(basename "$pidfile" | sed 's/.*-\([0-9]*\)\.pid$/\1/')

            if is_tunnel_running "$pidfile"; then
                local pid
                pid=$(cat "$pidfile")
                log_info "Stopping tunnel process $pid (port $port)"
                kill "$pid" 2>/dev/null || true
                cleaned=$((cleaned + 1))
            fi
            rm -f "$pidfile"
        fi
    done

    if [[ $cleaned -eq 0 ]]; then
        log_info "No active tunnels found for $instance_name ($environment)"
    else
        log_info "Cleaned up $cleaned tunnel(s)"
    fi
}

# Connect directly to the instance
connect_to_instance() {
    local instance_name="$1"
    local environment="$2"

    log_info "Establishing direct connection to instance..."

    local instance_id
    if ! instance_id=$(get_instance_id "$instance_name" "$environment"); then
        return $?
    fi

    log_info "Connecting to instance: $instance_id"

    # Start SSM session
    if ! aws ssm start-session --target "$instance_id"; then
        log_error "Failed to start SSM session to instance $instance_id"
        log_error "Please ensure the instance has SSM agent installed and the necessary IAM permissions"
        return 6
    fi
}

# Create a port forwarding tunnel
create_tunnel() {
    local instance_name="$1"
    local environment="$2"
    local port_number="$3"
    local local_port_number="$4"
    local background_mode="${5:-false}"

    if [[ "$background_mode" == "true" ]]; then
        log_info "Creating background port forwarding tunnel..."
    else
        log_info "Creating port forwarding tunnel..."
    fi
    log_info "Local port $local_port_number -> Remote port $port_number"

    local instance_id
    if ! instance_id=$(get_instance_id "$instance_name" "$environment"); then
        return $?
    fi

    log_info "Creating tunnel to instance: $instance_id"

    # Clean up any existing tunnel on the same local port first
    cleanup_tunnels "$instance_name" "$environment" "$local_port_number"

    if [[ "$background_mode" == "true" ]]; then
        # Create background tunnel
        local pidfile
        pidfile=$(get_tunnel_pidfile "$instance_name" "$environment" "$local_port_number")

        # Set global variables for signal handling
        CURRENT_PIDFILE="$pidfile"

        # Start tunnel in background and capture PID
        local tunnel_params
        tunnel_params=$(jq -nc --arg port "$port_number" --arg local_port "$local_port_number" \
            '{portNumber: [$port], localPortNumber: [$local_port]}')

        aws ssm start-session \
            --target "$instance_id" \
            --document-name AWS-StartPortForwardingSession \
            --parameters "$tunnel_params" \
            > /dev/null 2>&1 &

        local tunnel_pid=$!
        BACKGROUND_TUNNEL_PID="$tunnel_pid"
        echo "$tunnel_pid" > "$pidfile"

        # Give the tunnel a moment to establish
        sleep 2

        # Verify tunnel is still running
        if ! is_tunnel_running "$pidfile"; then
            log_error "Failed to create background tunnel to instance $instance_id"
            return 7
        fi

        log_info "✓ Background tunnel created successfully (PID: $tunnel_pid)"
        log_info "Tunnel: localhost:$local_port_number -> $instance_id:$port_number"
        log_info "Use '$SCRIPT_NAME $instance_name $environment cleanup' to stop the tunnel"
        return 0
    else
        # Start foreground tunnel
        local tunnel_params
        tunnel_params=$(jq -nc --arg port "$port_number" --arg local_port "$local_port_number" \
            '{portNumber: [$port], localPortNumber: [$local_port]}')

        if ! aws ssm start-session \
            --target "$instance_id" \
            --document-name AWS-StartPortForwardingSession \
            --parameters "$tunnel_params"; then
            log_error "Failed to create port forwarding tunnel to instance $instance_id"
            log_error "Please ensure the instance has SSM agent installed and the necessary IAM permissions"
            return 7
        fi
    fi
}

# Main function
main() {
    # Check if any arguments provided before setting variables
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 1
    fi

    # Parse command line arguments
    if [[ $# -lt 2 ]]; then
        show_usage
        exit 1
    fi

    local instance_name="$1"
    local environment="$2"
    local connection_method="${3:-$DEFAULT_CONNECTION_METHOD}"
    local port_number="${4:-}"
    local local_port_number="${5:-}"

    # For tunnel/background modes, require both port numbers
    if [[ ("$connection_method" == "tunnel" || "$connection_method" == "background") && $# -lt 5 ]]; then
        log_error "Tunnel and background modes require both port numbers"
        show_usage
        exit 1
    fi

    # Cleanup mode only needs instance name and environment
    if [[ "$connection_method" == "cleanup" ]]; then
        cleanup_tunnels "$instance_name" "$environment"
        exit 0
    fi

    # Set up signal handlers for cleanup
    setup_signal_handlers

    # Perform checks
    check_dependencies
    check_aws_config

    # Validate AWS account for staging/production/management
    if ! validate_aws_account "$environment"; then
        exit $?
    fi

    # Validate inputs
    if ! validate_inputs "$instance_name" "$environment" "$connection_method" "$port_number" "$local_port_number"; then
        log_error "Input validation failed"
        show_usage
        exit 1
    fi

    # Execute the appropriate function
    case "$connection_method" in
        connect)
            connect_to_instance "$instance_name" "$environment"
            ;;
        tunnel)
            create_tunnel "$instance_name" "$environment" "$port_number" "$local_port_number" "false"
            ;;
        background)
            create_tunnel "$instance_name" "$environment" "$port_number" "$local_port_number" "true"
            ;;
    esac
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
